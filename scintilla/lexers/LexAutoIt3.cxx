// Scintilla source code edit control
// @file LexAutoIt3.cxx
// Lexer for AutoIt3 https://www.autoitscript.com/site/
// by Jos van der Zande, jvdzande@yahoo.com
//
// Copyright for Scintilla: 1998-2001 by Neil Hodgson <neilh@scintilla.org>
// The License.txt file describes the conditions under which this software may be distributed.
// Scintilla source code edit control

#include <cassert>
#include <cstring>

#include <string>
#include <string_view>

#include "ILexer.h"
#include "Scintilla.h"
#include "SciLexer.h"

#include "WordList.h"
#include "LexAccessor.h"
#include "Accessor.h"
#include "StyleContext.h"
#include "CharacterSet.h"
#include "StringUtils.h"
#include "LexerModule.h"

using namespace Lexilla;

namespace {

//KeywordIndex++Autogenerated -- start of section automatically generated
enum {
	KeywordIndex_Keyword = 0,
	KeywordIndex_Function = 1,
	KeywordIndex_Macro = 2,
	KeywordIndex_SentKey = 3,
	KeywordIndex_Directive = 4,
	KeywordIndex_Special = 5,
	KeywordIndex_UserDefinedFunction = 6,
};
//KeywordIndex--Autogenerated -- end of section automatically generated

constexpr bool IsAu3TypeCharacter(int ch) noexcept {
	return ch == '$';
}

constexpr bool IsAu3WordChar(int ch) noexcept {
	return IsAlphaNumeric(ch) || ch == '_';
}

constexpr bool IsAu3WordStart(int ch) noexcept {
	return IsAlphaNumeric(ch) || ch == '_' || ch == '@' || ch == '#' || ch == '$' || ch == '.';
}

constexpr bool IsAu3Operator(int ch) noexcept {
	return ch == '+' || ch == '-' || ch == '*' || ch == '/' ||
		ch == '&' || ch == '^' || ch == '=' || ch == '<' || ch == '>' ||
		ch == '(' || ch == ')' || ch == '[' || ch == ']' || ch == ',';
}

///////////////////////////////////////////////////////////////////////////////
// GetSendKey() filters the portion before and after a/multiple space(s)
// and return the first portion to be looked-up in the table
// also check if the second portion is valid... (up, down.on.off, toggle or a number)
///////////////////////////////////////////////////////////////////////////////
bool GetSendKey(const char *szLine, char *szKey) noexcept {
	bool nFlag = false;
	bool nStartFound = false;
	unsigned nKeyPos = 0;
	unsigned nSpecPos = 0;
	bool nSpecNum = true;
	unsigned nPos = 0;
	char cTemp;
	char szSpecial[128];

	// split the portion of the sendkey in the part before and after the spaces
	while ((cTemp = szLine[nPos++]) != '\0') {
		// skip leading Ctrl/Shift/Alt state
		if (cTemp == '{') {
			nStartFound = true;
		}
		if (nStartFound) {
			if ((cTemp == ' ') && !nFlag) { // get the stuff till first space
				nFlag = true;
				// Add } to the end of the first bit for table lookup later.
				szKey[nKeyPos++] = '}';
			} else if (cTemp == ' ') {
				// skip other spaces
			} else if (!nFlag) {
				// save first portion into var till space or } is hit
				szKey[nKeyPos++] = cTemp;
			} else if (nFlag && (cTemp != '}')) {
				// Save second portion into var...
				szSpecial[nSpecPos++] = cTemp;
				// check if Second portion is all numbers for repeat function
				if (!IsADigit(cTemp)) {
					nSpecNum = false;
				}
			}
		}
	}

	// Check if the second portion is either a number or one of these keywords
	szSpecial[nSpecPos] = '\0';
	nFlag = true;
	if (nSpecNum || StrEqualsAny(szSpecial, "down", "up", "on", "off", "toggle")) {
		nFlag = false;
		if (nKeyPos > 2) {
			// remove {}
			nKeyPos -= 2;
			memmove(szKey, szKey + 1, nKeyPos);
			szKey[nKeyPos] = '\0';
		}
	}
	return nFlag;  // 1 is bad, 0 is good

}

// Routine to check the last "none comment" character on a line to see if it's a continuation
bool IsContinuationLine(LexAccessor &styler, Sci_Line szLine) noexcept {
	const Sci_Position nsPos = styler.LineStart(szLine);
	Sci_Position nePos = styler.LineStart(szLine + 1) - 2;
	//int stylech = styler.StyleAt(nsPos);
	while (nsPos < nePos) {
		//stylech = styler.StyleAt(nePos);
		const int stylech = styler.StyleAt(nsPos);
		if (!(stylech == SCE_AU3_COMMENT)) {
			const char ch = styler.SafeGetCharAt(nePos);
			if (!isspacechar(ch)) {
				return ch == '_';
			}
		}
		nePos--; // skip to next char
	}
	return false;
}

// syntax highlighting logic
void ColouriseAU3Doc(Sci_PositionU startPos, Sci_Position length, int initStyle, LexerWordList keywordLists, Accessor &styler) {
	// find the first previous line without continuation character at the end
	const Sci_Position s_startPos = startPos;
	// When not inside a Block comment: find First line without _
	if (!(initStyle == SCE_AU3_COMMENTBLOCK)) {
		Sci_Line lineCurrent = styler.GetLine(startPos);
		while ((lineCurrent > 0 && IsContinuationLine(styler, lineCurrent)) ||
			(lineCurrent > 1 && IsContinuationLine(styler, lineCurrent - 1))) {
			lineCurrent--;
			startPos = styler.LineStart(lineCurrent); // get start position
			initStyle = 0;		// reset the start style to 0
		}
	}
	// Set the new length to include it from the start and set the start position
	length = length + s_startPos - startPos;	// correct the total length to process
	styler.StartAt(startPos);

	StyleContext sc(startPos, length, initStyle, styler);
	char si;	// string indicator "=1 '=2
	char ni;	// Numeric indicator error=9 normal=0 normal+dec=1 hex=2 Enot=3
	char ci;	// comment indicator 0=not linecomment(;)
	char s_save[128] = "";
	si = 0;
	ni = 0;
	ci = 0;
	//$$$
	for (; sc.More(); sc.Forward()) {
		char s[128];
		sc.GetCurrentLowered(s, sizeof(s));
		// **********************************************
		// save the total current word for eof processing
		if (IsAu3WordChar(sc.ch) || sc.ch == '}') {
			const size_t tp = strlen(s);
			memcpy(s_save, s, tp);
			s_save[tp] = '\0';
			if (tp < 127) {
				s_save[tp] = static_cast<char>(MakeLowerCase(sc.ch));
				s_save[tp + 1] = '\0';
			}
		}
		// **********************************************
		//
		switch (sc.state) {
		case SCE_AU3_COMMENTBLOCK:
		{
			//Reset at line end
			if (sc.atLineEnd) {
				ci = 0;
				if (StrEqualsAny(s, "#ce", "#comments-end")) {
					if (sc.atLineEnd) {
						sc.SetState(SCE_AU3_DEFAULT);
					} else {
						sc.SetState(SCE_AU3_COMMENTBLOCK);
					}
				}
				break;
			}
			//skip rest of line when a ; is encountered
			if (sc.chPrev == ';') {
				ci = 2;
				sc.SetState(SCE_AU3_COMMENTBLOCK);
			}
			// skip rest of the line
			if (ci == 2) {
				break;
			}
			// check when first character is detected on the line
			if (ci == 0) {
				if (IsAu3WordStart(sc.ch) || IsAu3Operator(sc.ch)) {
					ci = 1;
					sc.SetState(SCE_AU3_COMMENTBLOCK);
				}
				break;
			}
			if (!(IsAu3WordChar(sc.ch) || (sc.ch == '-' && StrEqual(s, "#comments")))) {
				if (StrEqualsAny(s, "#ce", "#comments-end")) {
					sc.SetState(SCE_AU3_COMMENT);    // set to comment line for the rest of the line
				} else {
					ci = 2;    // line doesn't begin with #CE so skip the rest of the line
				}
			}
			break;
		}
		case SCE_AU3_COMMENT:
		{
			if (sc.atLineStart) {
				sc.SetState(SCE_AU3_DEFAULT);
			}
			break;
		}
		case SCE_AU3_OPERATOR:
		{
			// check if it's a COMobject
			if (sc.chPrev == '.' && IsAu3WordChar(sc.ch)) {
				sc.SetState(SCE_AU3_COMOBJ);
			} else {
				sc.SetState(SCE_AU3_DEFAULT);
			}
			break;
		}
		case SCE_AU3_SPECIAL:
		{
			if (sc.ch == ';') {
				sc.SetState(SCE_AU3_COMMENT);
			}
			if (sc.atLineEnd) {
				sc.SetState(SCE_AU3_DEFAULT);
			}
			break;
		}
		case SCE_AU3_KEYWORD:
		{
			if (!(IsAu3WordChar(sc.ch) || (sc.ch == '-' && StrEqualsAny(s, "#comments", "#include")))) {
				if (!IsAu3TypeCharacter(sc.ch)) {
					if (StrEqualsAny(s, "#cs", "#comments-start")) {
						sc.ChangeState(SCE_AU3_COMMENTBLOCK);
						sc.SetState(SCE_AU3_COMMENTBLOCK);
						break;
					} else if (keywordLists[KeywordIndex_Keyword].InList(s)) {
						sc.ChangeState(SCE_AU3_KEYWORD);
						sc.SetState(SCE_AU3_DEFAULT);
					} else if (keywordLists[KeywordIndex_Function].InListPrefixed(s, '(')) {
						sc.ChangeState(SCE_AU3_FUNCTION);
						sc.SetState(SCE_AU3_DEFAULT);
					} else if (s[0] == '@' && keywordLists[KeywordIndex_Macro].InList(s + 1)) {
						sc.ChangeState(SCE_AU3_MACRO);
						sc.SetState(SCE_AU3_DEFAULT);
					} else if (s[0] == '#' && keywordLists[KeywordIndex_Directive].InList(s + 1)) {
						sc.ChangeState(SCE_AU3_PREPROCESSOR);
						sc.SetState(SCE_AU3_DEFAULT);
						if (StrEqual(s, "#include")) {
							si = 3;   // use to determine string start for #inlude <>
						}
					} else if (s[0] == '#' && keywordLists[KeywordIndex_Special].InList(s + 1)) {
						sc.ChangeState(SCE_AU3_SPECIAL);
						sc.SetState(SCE_AU3_SPECIAL);
#if 0
					} else if ((keywordLists[KeywordIndex_Expand].InList(s)) && (!IsAu3Operator(sc.ch))) {
						sc.ChangeState(SCE_AU3_EXPAND);
						sc.SetState(SCE_AU3_DEFAULT);
#endif
					} else if (keywordLists[KeywordIndex_UserDefinedFunction].InListPrefixed(s, '(')) {
						sc.ChangeState(SCE_AU3_UDF);
						sc.SetState(SCE_AU3_DEFAULT);
					} else if (StrEqual(s, "_")) {
						sc.ChangeState(SCE_AU3_OPERATOR);
						sc.SetState(SCE_AU3_DEFAULT);
					} else if (!IsAu3WordChar(sc.ch)) {
						sc.ChangeState(SCE_AU3_DEFAULT);
						sc.SetState(SCE_AU3_DEFAULT);
					}
				}
			}
			if (sc.atLineEnd) {
				sc.SetState(SCE_AU3_DEFAULT);
			}
			break;
		}
		case SCE_AU3_NUMBER:
		{
			// Numeric indicator error=9 normal=0 normal+dec=1 hex=2 E-not=3
			//
			// test for Hex notation
			if (StrEqual(s, "0") && (sc.ch == 'x' || sc.ch == 'X') && ni == 0) {
				ni = 2;
				break;
			}
			// test for E notation
			if (IsADigit(sc.chPrev) && (sc.ch == 'e' || sc.ch == 'E') && ni <= 1) {
				ni = 3;
				break;
			}
			//  Allow Hex characters inside hex numeric strings
			if ((ni == 2) &&
				(sc.ch == 'a' || sc.ch == 'b' || sc.ch == 'c' || sc.ch == 'd' || sc.ch == 'e' || sc.ch == 'f' ||
					sc.ch == 'A' || sc.ch == 'B' || sc.ch == 'C' || sc.ch == 'D' || sc.ch == 'E' || sc.ch == 'F')) {
				break;
			}
			// test for 1 dec point only
			if (sc.ch == '.') {
				if (ni == 0) {
					ni = 1;
				} else {
					ni = 9;
				}
				break;
			}
			// end of numeric string ?
			if (!(IsADigit(sc.ch))) {
				if (ni == 9) {
					sc.ChangeState(SCE_AU3_DEFAULT);
				}
				sc.SetState(SCE_AU3_DEFAULT);
			}
			break;
		}
		case SCE_AU3_VARIABLE:
		{
			// Check if it's a COMObject
			if (sc.ch == '.' && !IsADigit(sc.chNext)) {
				sc.SetState(SCE_AU3_OPERATOR);
			} else if (!IsAu3WordChar(sc.ch)) {
				sc.SetState(SCE_AU3_DEFAULT);
			}
			break;
		}
		case SCE_AU3_COMOBJ:
		{
			if (!(IsAu3WordChar(sc.ch))) {
				sc.SetState(SCE_AU3_DEFAULT);
			}
			break;
		}
		case SCE_AU3_STRING:
		{
			// check for " to end a double qouted string or
			// check for ' to end a single qouted string
			if ((si == 1 && sc.ch == '\"') || (si == 2 && sc.ch == '\'') || (si == 3 && sc.ch == '>')) {
				sc.ForwardSetState(SCE_AU3_DEFAULT);
				si = 0;
				break;
			}
			if (sc.atLineEnd) {
				si = 0;
				// at line end and not found a continuation char then reset to default
				if (!IsContinuationLine(styler, sc.currentLine)) {
					sc.SetState(SCE_AU3_DEFAULT);
					break;
				}
			}
			// find Sendkeys in a STRING
			if (sc.ch == '{' || sc.ch == '+' || sc.ch == '!' || sc.ch == '^' || sc.ch == '#') {
				sc.SetState(SCE_AU3_SENT);
			}
			break;
		}
		case SCE_AU3_SENT:
		{
			// Send key string ended
			if (sc.chPrev == '}' && sc.ch != '}') {
				// set color to SENDKEY when valid sendkey .. else set back to regular string
				char sk[128] = "";
				// split {111 222} and return {111} and check if 222 is valid.
				// if return code = 1 then invalid 222 so must be string
				if (GetSendKey(s, sk)) {
					sc.ChangeState(SCE_AU3_STRING);
				}
				// if single char between {?} then it's ok as sendkey for a single character
				else if (sk[0] != '\0' && sk[1] == '\0') {
					sc.ChangeState(SCE_AU3_SENT);
				}
				// if sendkey {111} is in table then ok as sendkey
				else if (keywordLists[KeywordIndex_SentKey].InList(sk)) {
					sc.ChangeState(SCE_AU3_SENT);
				} else {
					sc.ChangeState(SCE_AU3_STRING);
				}
				sc.SetState(SCE_AU3_STRING);
			} else {
				// check if the start is a valid SendKey start
				Sci_Position nPos = 0;
				int nState = 1;
				char cTemp;
				while (!(nState == 2) && ((cTemp = s[nPos]) != '\0')) {
					if (cTemp == '{' && nState == 1) {
						nState = 2;
					}
					if (nState == 1 && !AnyOf(cTemp, '+', '!', '^', '#')) {
						nState = 0;
					}
					nPos++;
				}
				//Verify characters infront of { ... if not assume  regular string
				if (nState == 1 && !AnyOf(sc.ch, '{', '+', '!', '^', '#')) {
					sc.ChangeState(SCE_AU3_STRING);
					sc.SetState(SCE_AU3_STRING);
				}
				// If invalid character found then assume it's a regular string
				if (nState == 0) {
					sc.ChangeState(SCE_AU3_STRING);
					sc.SetState(SCE_AU3_STRING);
				}
			}
			// check if next portion is again a sendkey
			if (sc.atLineEnd) {
				sc.ChangeState(SCE_AU3_STRING);
				sc.SetState(SCE_AU3_DEFAULT);
				si = 0;  // reset string indicator
			}
			//* check in next characters following a sentkey are again a sent key
			// Need this test incase of 2 sentkeys like {F1}{ENTER} but not detect {{}
			if (sc.state == SCE_AU3_STRING && (sc.ch == '{' || sc.ch == '+' || sc.ch == '!' || sc.ch == '^' || sc.ch == '#')) {
				sc.SetState(SCE_AU3_SENT);
			}
			// check to see if the string ended...
			// Sendkey string isn't complete but the string ended....
			if ((si == 1 && sc.ch == '\"') || (si == 2 && sc.ch == '\'')) {
				sc.ChangeState(SCE_AU3_STRING);
				sc.ForwardSetState(SCE_AU3_DEFAULT);
			}
			break;
		}
		}  //switch (sc.state)

		// Determine if a new state should be entered:

		if (sc.state == SCE_AU3_DEFAULT) {
			if (sc.ch == ';') {
				sc.SetState(SCE_AU3_COMMENT);
			} else if (sc.ch == '#') {
				sc.SetState(SCE_AU3_KEYWORD);
			} else if (sc.ch == '$') {
				sc.SetState(SCE_AU3_VARIABLE);
			} else if (sc.ch == '.' && !IsADigit(sc.chNext)) {
				sc.SetState(SCE_AU3_OPERATOR);
			} else if (sc.ch == '@') {
				sc.SetState(SCE_AU3_KEYWORD);
				/*} else if (sc.ch == '_') {
					sc.SetState(SCE_AU3_KEYWORD);*/
			} else if (sc.ch == '<' && si == 3) {
				sc.SetState(SCE_AU3_STRING); // string after #include
			} else if (sc.ch == '\"') {
				sc.SetState(SCE_AU3_STRING);
				si = 1;
			} else if (sc.ch == '\'') {
				sc.SetState(SCE_AU3_STRING);
				si = 2;
			} else if (IsNumberStart(sc.ch, sc.chNext)) {
				sc.SetState(SCE_AU3_NUMBER);
				ni = 0;
			} else if (IsAu3WordStart(sc.ch)) {
				sc.SetState(SCE_AU3_KEYWORD);
			} else if (IsAu3Operator(sc.ch)) {
				sc.SetState(SCE_AU3_OPERATOR);
			} else if (sc.atLineEnd) {
				sc.SetState(SCE_AU3_DEFAULT);
			}
		}
	}	//for (; sc.More(); sc.Forward())

	//*************************************
	// Colourize the last word correctly
	//*************************************
	if (sc.state == SCE_AU3_KEYWORD) {
		if (StrEqualsAny(s_save, "#cs", "#comments-start")) {
			sc.ChangeState(SCE_AU3_COMMENTBLOCK);
			sc.SetState(SCE_AU3_COMMENTBLOCK);
		} else if (keywordLists[KeywordIndex_Keyword].InList(s_save)) {
			sc.ChangeState(SCE_AU3_KEYWORD);
			sc.SetState(SCE_AU3_KEYWORD);
		} else if (keywordLists[KeywordIndex_Function].InListPrefixed(s_save, '(')) {
			sc.ChangeState(SCE_AU3_FUNCTION);
			sc.SetState(SCE_AU3_FUNCTION);
		} else if (s_save[0] == '@' && keywordLists[KeywordIndex_Macro].InList(s_save + 1)) {
			sc.ChangeState(SCE_AU3_MACRO);
			sc.SetState(SCE_AU3_MACRO);
		} else if (s_save[0] == '#' && keywordLists[KeywordIndex_Directive].InList(s_save + 1)) {
			sc.ChangeState(SCE_AU3_PREPROCESSOR);
			sc.SetState(SCE_AU3_PREPROCESSOR);
		} else if (s_save[0] == '#' && keywordLists[KeywordIndex_Special].InList(s_save + 1)) {
			sc.ChangeState(SCE_AU3_SPECIAL);
			sc.SetState(SCE_AU3_SPECIAL);
#if 0
		} else if (keywordLists[KeywordIndex_Expand].InList(s_save) && sc.atLineEnd) {
			sc.ChangeState(SCE_AU3_EXPAND);
			sc.SetState(SCE_AU3_EXPAND);
#endif
		} else if (keywordLists[KeywordIndex_UserDefinedFunction].InListPrefixed(s_save, '(')) {
			sc.ChangeState(SCE_AU3_UDF);
			sc.SetState(SCE_AU3_UDF);
		} else {
			sc.ChangeState(SCE_AU3_DEFAULT);
			sc.SetState(SCE_AU3_DEFAULT);
		}
	}
	if (sc.state == SCE_AU3_SENT) {
		// Send key string ended
		if (sc.chPrev == '}' && sc.ch != '}') {
			// set color to SENDKEY when valid sendkey .. else set back to regular string
			char sk[128] = "";
			// split {111 222} and return {111} and check if 222 is valid.
			// if return code = 1 then invalid 222 so must be string
			if (GetSendKey(s_save, sk)) {
				sc.ChangeState(SCE_AU3_STRING);
			}
			// if single char between {?} then it's ok as sendkey for a single character
			else if (sk[0] != '\0' && sk[1] == '\0') {
				sc.ChangeState(SCE_AU3_SENT);
			}
			// if sendkey {111} is in table then ok as sendkey
			else if (keywordLists[KeywordIndex_SentKey].InList(sk)) {
				sc.ChangeState(SCE_AU3_SENT);
			} else {
				sc.ChangeState(SCE_AU3_STRING);
			}
			sc.SetState(SCE_AU3_STRING);
		}
		// check if next portion is again a sendkey
		if (sc.atLineEnd) {
			sc.ChangeState(SCE_AU3_STRING);
			sc.SetState(SCE_AU3_DEFAULT);
		}
	}
	//*************************************
	sc.Complete();
}

constexpr bool IsStreamCommentStyle(int style) noexcept {
	return style == SCE_AU3_COMMENT || style == SCE_AU3_COMMENTBLOCK;
}

// Routine to find first none space on the current line and return its Style
// needed for comment lines not starting on pos 1
int GetStyleFirstWord(LexAccessor &styler, Sci_Line szLine) noexcept {
	Sci_Position nsPos = styler.LineStart(szLine);
	const Sci_Position nePos = styler.LineStart(szLine + 1) - 1;
	while (isspacechar(styler.SafeGetCharAt(nsPos)) && nsPos < nePos) {
		nsPos++; // skip to next char

	} // End While
	return styler.StyleAt(nsPos);

}

void FoldAU3Doc(Sci_PositionU startPos, Sci_Position length, int /*initStyle*/, LexerWordList /*keywordLists*/, Accessor &styler) {
	const Sci_PositionU endPos = startPos + length;
	constexpr bool foldInComment = false;
	Sci_Line lineCurrent = styler.GetLine(startPos);
	// vars for style of previous/current/next lines
	int style = GetStyleFirstWord(styler, lineCurrent);
	int stylePrev = 0;
	// find the first previous line without continuation character at the end
	while ((lineCurrent > 0 && IsContinuationLine(styler, lineCurrent)) ||
		(lineCurrent > 1 && IsContinuationLine(styler, lineCurrent - 1))) {
		lineCurrent--;
		startPos = styler.LineStart(lineCurrent);
	}
	if (lineCurrent > 0) {
		stylePrev = GetStyleFirstWord(styler, lineCurrent - 1);
	}
	// vars for getting first word to check for keywords
	bool FirstWordStart = false;
	bool FirstWordEnd = false;
	char szKeyword[11] = "";
	int	 szKeywordlen = 0;
	char szThen[5] = "";
	int	 szThenlen = 0;
	bool ThenFoundLast = false;
	// var for indentlevel
	int levelCurrent = SC_FOLDLEVELBASE;
	if (lineCurrent > 0) {
		levelCurrent = styler.LevelAt(lineCurrent - 1) >> 16;
	}
	Sci_PositionU lineStartNext = styler.LineStart(lineCurrent + 1);
	lineStartNext = sci::min(lineStartNext, endPos);
	int levelNext = levelCurrent;
	char chPrev = ' ';
	while (startPos < endPos) {
		const char ch = styler[startPos];
		// get the style for the current character need to check in comment
		const int stylech = styler.StyleAt(startPos);
		// get first word for the line for indent check max 9 characters
		if (FirstWordStart && (!(FirstWordEnd))) {
			if (!IsAu3WordChar(ch)) {
				FirstWordEnd = true;
				szKeyword[szKeywordlen] = '\0';
			} else {
				if (szKeywordlen < 10) {
					szKeyword[szKeywordlen++] = UnsafeLower(ch);
				}
			}
		}
		// start the capture of the first word
		if (!(FirstWordStart)) {
			if (IsAu3WordChar(ch) || IsAu3WordStart(ch) || ch == ';') {
				FirstWordStart = true;
				szKeyword[szKeywordlen++] = UnsafeLower(ch);
			}
		}
		// only process this logic when not in comment section
		if (!(stylech == SCE_AU3_COMMENT)) {
			if (ThenFoundLast) {
				if (IsAu3WordChar(ch)) {
					ThenFoundLast = false;
				}
			}
			// find out if the word "then" is the last on a "if" line
			if (FirstWordEnd && StrEqual(szKeyword, "if")) {
				if (szThenlen == 4) {
					szThen[0] = szThen[1];
					szThen[1] = szThen[2];
					szThen[2] = szThen[3];
					szThen[3] = UnsafeLower(ch);
					if (StrEqual(szThen, "then")) {
						ThenFoundLast = true;
					}
				} else {
					szThen[szThenlen++] = UnsafeLower(ch);
					if (szThenlen == 5) {
						szThen[4] = '\0';
					}
				}
			}
		}
		// End of Line found so process the information
		++startPos;
		if (startPos == lineStartNext) {
			// **************************
			// Folding logic for Keywords
			// **************************
			// if a keyword is found on the current line and the line doesn't end with _ (continuation)
			//    and we are not inside a commentblock.
			if (szKeywordlen > 0 && (!(chPrev == '_')) &&
				((!(IsStreamCommentStyle(style)) || foldInComment))) {
				szKeyword[szKeywordlen] = '\0';
				// only fold "if" last keyword is "then"  (else it's a one line if)
				if (StrEqual(szKeyword, "if") && ThenFoundLast) {
					levelNext++;
				}
				// create new fold for these words
				if (StrEqualsAny(szKeyword, "do", "for", "func", "while", "with", "#region")) {
					levelNext++;
				}
				// create double Fold for select and switch because Case will subtract one of the current level
				if (StrEqualsAny(szKeyword, "select", "switch")) {
					levelNext++;
					levelNext++;
				}
				// end the fold for these words before the current line
				if (StrEqualsAny(szKeyword, "endfunc", "endif", "next", "until", "endwith", "wend")) {
					levelNext--;
					levelCurrent--;
				}
				// end the fold for these words before the current line and Start new fold
				if (StrEqualsAny(szKeyword, "case", "else", "elseif")) {
					levelCurrent--;
				}
				// end the double fold for this word before the current line
				if (StrEqualsAny(szKeyword, "endselect", "endswitch")) {
					levelNext--;
					levelNext--;
					levelCurrent--;
					levelCurrent--;
				}
				// end the fold for these words on the current line
				if (StrEqual(szKeyword, "#endregion")) {
					levelNext--;
				}
			}
			// Preprocessor and Comment folding
			const int styleNext = GetStyleFirstWord(styler, lineCurrent + 1);
			// *************************************
			// Folding logic for preprocessor blocks
			// *************************************
			// process preprosessor line
			if (style == SCE_AU3_PREPROCESSOR) {
				if (!(stylePrev == SCE_AU3_PREPROCESSOR) && (styleNext == SCE_AU3_PREPROCESSOR)) {
					levelNext++;
				}
				// fold till the last line for normal comment lines
				else if (stylePrev == SCE_AU3_PREPROCESSOR && !(styleNext == SCE_AU3_PREPROCESSOR)) {
					levelNext--;
				}
			}
			// *********************************
			// Folding logic for Comment blocks
			// *********************************
			if (IsStreamCommentStyle(style)) {
				// Start of a comment block
				if (!(stylePrev == style) && IsStreamCommentStyle(styleNext) && styleNext == style) {
					levelNext++;
				}
				// fold till the last line for normal comment lines
				else if (IsStreamCommentStyle(stylePrev) && !(styleNext == SCE_AU3_COMMENT)
					&& stylePrev == SCE_AU3_COMMENT && style == SCE_AU3_COMMENT) {
					levelNext--;
				}
				// fold till the one but last line for Blockcomment lines
				else if (IsStreamCommentStyle(stylePrev)
					&& !(styleNext == SCE_AU3_COMMENTBLOCK) && style == SCE_AU3_COMMENTBLOCK) {
					levelNext--;
					levelCurrent--;
				}
			}
			levelNext = sci::max(levelNext, SC_FOLDLEVELBASE);
			const int levelUse = levelCurrent;
			int lev = levelUse | levelNext << 16;
			if (levelUse < levelNext) {
				lev |= SC_FOLDLEVELHEADERFLAG;
			}
			styler.SetLevel(lineCurrent, lev);
			// reset values for the next line
			lineCurrent++;
			lineStartNext = styler.LineStart(lineCurrent + 1);
			lineStartNext = sci::min(lineStartNext, endPos);
			stylePrev = style;
			style = styleNext;
			levelCurrent = levelNext;
			// if the last character is an Underscore then don't reset since the line continues on the next line.
			if (!(chPrev == '_')) {
				szKeywordlen = 0;
				szThenlen = 0;
				FirstWordStart = false;
				FirstWordEnd = false;
				ThenFoundLast = false;
			}
		}
		// save the last processed character
		if (static_cast<unsigned char>(ch) > ' ') {
			chPrev = ch;
		}
	}
}

}

LexerModule lmAutoIt3(SCLEX_AUTOIT3, ColouriseAU3Doc, "au3", FoldAU3Doc);
