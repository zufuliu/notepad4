// Scintilla source code edit control
/** @file LexHTML.cxx
 ** Lexer for HTML.
 **/
// Copyright 1998-2005 by Neil Hodgson <neilh@scintilla.org>
// The License.txt file describes the conditions under which this software may be distributed.

#include <cassert>
#include <cstring>

#include <string>
#include <string_view>

#include "ILexer.h"
#include "Scintilla.h"
#include "SciLexer.h"

#include "WordList.h"
#include "LexAccessor.h"
#include "Accessor.h"
#include "StyleContext.h"
#include "CharacterSet.h"
#include "StringUtils.h"
#include "LexerModule.h"
#include "DocUtils.h"

using namespace Lexilla;

namespace {

//KeywordIndex++Autogenerated -- start of section automatically generated
enum {
	KeywordIndex_Tag = 0,
	KeywordIndex_VoidTag = 1,
	KeywordIndex_JavaScript = 2,
	KeywordIndex_VBScript = 3,
	KeywordIndex_SGML = 4,
	KeywordIndex_Attribute = 5,
	MaxKeywordSize = 32,
};
//KeywordIndex--Autogenerated -- end of section automatically generated

#define SCE_HA_JS (SCE_HJA_START - SCE_HJ_START)
#define SCE_HA_VBS (SCE_HBA_START - SCE_HB_START)

enum script_type { eScriptNone = 0, eScriptJS, eScriptVBS, eScriptXML, eScriptSGML, eScriptSGMLblock, eScriptComment };
enum script_mode { eHtml = 0, eNonHtmlScript, eNonHtmlPreProc, eNonHtmlScriptPreProc };

// Put an upper limit to bound time taken for unexpected text.
constexpr Sci_PositionU maxLengthCheck = 200;

script_type segIsScriptingIndicator(const LexAccessor &styler, Sci_PositionU start, Sci_PositionU end, script_type prevValue) {
	char s[128];
	styler.GetRangeLowered(start, end, s, sizeof(s));
	//Platform::DebugPrintf("Scripting indicator [%s]\n", s);
	if (strstr(s, "vbs"))
		return eScriptVBS;
	// https://html.spec.whatwg.org/multipage/scripting.html#attr-script-type
	// https://mimesniff.spec.whatwg.org/#javascript-mime-type
	if (strstr(s, "javas") || strstr(s, "ecmas") || strstr(s, "module") || strstr(s, "jscr"))
		return eScriptJS;

	return prevValue;
}

constexpr script_type ScriptOfState(int state) noexcept {
	if ((state >= SCE_HB_START && state <= SCE_HB_OPERATOR) || state == SCE_H_ASPAT || state == SCE_H_XCCOMMENT) {
		return eScriptVBS;
	}
	if ((state >= SCE_HJ_START) && (state <= SCE_HJ_TEMPLATELITERAL)) {
		return eScriptJS;
	}
	if ((state >= SCE_H_SGML_DEFAULT) && (state < SCE_H_SGML_BLOCK_DEFAULT)) {
		return eScriptSGML;
	}
	if (state == SCE_H_SGML_BLOCK_DEFAULT) {
		return eScriptSGMLblock;
	}
	return eScriptNone;
}

constexpr int statePrintForState(int state, script_mode inScriptType) noexcept {
	if (state >= SCE_HJ_START) {
		if ((state >= SCE_HB_START) && (state <= SCE_HB_OPERATOR)) {
			return state + ((inScriptType == eNonHtmlScript) ? 0 : SCE_HA_VBS);
		}
		if ((state >= SCE_HJ_START) && (state <= SCE_HJ_TEMPLATELITERAL)) {
			return state + ((inScriptType == eNonHtmlScript) ? 0 : SCE_HA_JS);
		}
	}

	return state;
}

constexpr int stateForPrintState(int StateToPrint) noexcept {
	if ((StateToPrint >= SCE_HBA_START) && (StateToPrint <= SCE_HBA_OPERATOR)) {
		return StateToPrint - SCE_HA_VBS;
	}
	if ((StateToPrint >= SCE_HJA_START) && (StateToPrint <= SCE_HJA_TEMPLATELITERAL)) {
		return StateToPrint - SCE_HA_JS;
	}

	return StateToPrint;
}

constexpr bool IsNumberChar(char ch) noexcept {
	return IsADigit(ch) || ch == '.' || ch == '-' || ch == '#';
}

constexpr bool IsEntityChar(int ch) noexcept {
	// Only allow [A-Za-z0-9.#-_:] in entities
	return IsAlphaNumeric(ch) || AnyOf(ch, '#', '.', '-', '_', ':');
}

constexpr bool IsSGMLEntityChar(int ch) noexcept {
	return IsAlphaNumeric(ch) || AnyOf(ch, '.', '-', '_');
}

constexpr bool isStringState(int state) noexcept {
	switch (state) {
	case SCE_HJ_DOUBLESTRING:
	case SCE_HJ_SINGLESTRING:
	case SCE_HJ_REGEX:
	case SCE_HJ_TEMPLATELITERAL:
	case SCE_HJA_DOUBLESTRING:
	case SCE_HJA_SINGLESTRING:
	case SCE_HJA_REGEX:
	case SCE_HJA_TEMPLATELITERAL:
	case SCE_HB_STRING:
	case SCE_HBA_STRING:
		return true;
	default:
		return false;
	}
}

constexpr bool stateAllowsTermination(int state, int ch) noexcept {
	if (!isStringState(state)) {
		if (state == SCE_H_ASP || state == SCE_H_ASPAT || state == SCE_H_XCCOMMENT || state >= SCE_HJ_START) {
			return ch == '%'; // ASP, JSP %>
		}
		return ch == '?'; // XML ?>
	}
	return false;
}

// not really well done, since it's only comments that should lex the %> and <%
constexpr bool isCommentASPState(int state) noexcept {
	return state == SCE_HJ_COMMENT
		|| state == SCE_HJ_COMMENTLINE
		|| state == SCE_HJ_COMMENTDOC
		|| state == SCE_HB_COMMENTLINE;
}

bool classifyAttribHTML(Sci_PositionU end, LexerWordList keywordLists, LexAccessor &styler, script_mode inScriptType, bool isXml) {
	char s[MaxKeywordSize];
	int chAttr = SCE_H_ATTRIBUTEUNKNOWN;
	bool isLanguageType = false;
	const Sci_PositionU start = styler.GetStartSegment();
	styler.GetRangeLowered(start, end, s, sizeof(s));
	if (IsNumberChar(s[0])) {
		chAttr = SCE_H_NUMBER;
	} else {
		if (inScriptType == eNonHtmlScript) {
			// see https://html.spec.whatwg.org/multipage/scripting.html
			if (StrEqualsAny(s, "type", "language")) {
				isLanguageType = true;
			}
		}
		if (isXml || keywordLists[KeywordIndex_Attribute].InList(s)) {
			chAttr = SCE_H_ATTRIBUTE;
		}
	}
	styler.ColorTo(end, chAttr);
	return isLanguageType;
}

// https://html.spec.whatwg.org/multipage/custom-elements.html#custom-elements-core-concepts
bool isHTMLCustomElement(const char *tag, size_t length, bool dashColon) noexcept {
	// check valid HTML custom element name: starts with an ASCII lower alpha and contains hyphen.
	// IsAlpha() is used for `html.tags.case.sensitive=1`.
	if (length < 2 || !IsAlpha(tag[0])) {
		return false;
	}
	return dashColon;
}

int classifyTagHTML(Sci_PositionU end, LexerWordList keywordLists, LexAccessor &styler, bool &tagDontFold, bool isXml, bool allowScripts) {
	char s[63 + 1];
	memset(s, 0, 4);
	const Sci_PositionU start = styler.GetStartSegment();
	styler.GetRange(start, end, s, sizeof(s));
	char *tag = s;
	if (tag[0] == '<') {
		tag += (tag[1] == '/') ? 2 : 1;
	}

	int chAttr = SCE_H_TAGUNKNOWN;
	bool customElement = false;
	if (tag[0] == '!') {
		chAttr = SCE_H_SGML_DEFAULT;
	} else if (isXml) {
		chAttr = SCE_H_TAG;
	} else {
		bool dashColon = false;
		char *t = tag;
		while (*t) {
			if (*t >= 'A' && *t <= 'Z') {
				*t |= 'a' - 'A';
			} else if (*t == ':' || *t == '-') {
				dashColon = true;
			}
			++t;
		}
		tagDontFold = keywordLists[KeywordIndex_VoidTag].InList(tag);
		if (tagDontFold || keywordLists[KeywordIndex_Tag].InList(tag)) {
			chAttr = SCE_H_TAG;
		} else if (isHTMLCustomElement(tag, t - tag, dashColon)) {
			customElement = true;
			chAttr = SCE_H_TAG;
		}
	}
	if (chAttr != SCE_H_TAGUNKNOWN) {
		styler.ColorTo(end, chAttr);
	}
	if (chAttr == SCE_H_TAG && !customElement) {
		if (allowScripts && StrEqual(tag, "script")) {
			// check to see if this is a self-closing tag by sniffing ahead
			bool isSelfClose = false;
			for (Sci_PositionU cPos = end; cPos < end + maxLengthCheck; cPos++) {
				const char ch = styler.SafeGetCharAt(cPos);
				if (ch == '\0' || ch == '>')
					break;
				if (ch == '/' && styler.SafeGetCharAt(cPos + 1) == '>') {
					isSelfClose = true;
					break;
				}
			}

			// do not enter a script state if the tag self-closed
			if (!isSelfClose)
				chAttr = SCE_H_SCRIPT;
		} else if (!isXml && StrEqual(tag, "comment")) {
			// IE only comment tag
			chAttr = SCE_H_COMMENT;
		}
	}
	return chAttr;
}

void classifyWordHTJS(Sci_PositionU end, LexerWordList keywordLists, LexAccessor &styler, script_mode inScriptType) {
	char s[31 + 1];
	styler.GetRange(styler.GetStartSegment(), end, s, sizeof(s));
	int chAttr = SCE_HJ_WORD;
	if (keywordLists[KeywordIndex_JavaScript].InList(s)) {
		chAttr = SCE_HJ_KEYWORD;
	}
	styler.ColorTo(end, statePrintForState(chAttr, inScriptType));
}

int classifyWordHTVB(Sci_PositionU end, LexerWordList keywordLists, LexAccessor &styler, script_mode inScriptType) {
	int chAttr = SCE_HB_IDENTIFIER;
	char s[32];
	styler.GetRangeLowered(styler.GetStartSegment(), end, s, sizeof(s));
	if (keywordLists[KeywordIndex_VBScript].InList(s)) {
		chAttr = SCE_HB_WORD;
		if (StrEqual(s, "rem"))
			chAttr = SCE_HB_COMMENTLINE;
	}
	styler.ColorTo(end, statePrintForState(chAttr, inScriptType));
	if (chAttr == SCE_HB_COMMENTLINE)
		return SCE_HB_COMMENTLINE;
	else
		return SCE_HB_DEFAULT;
}

// Return the first state to reach when entering a scripting language
constexpr int StateForScript(script_type scriptLanguage) noexcept {
	switch (scriptLanguage) {
	case eScriptVBS:
		return SCE_HB_START;
	case eScriptXML:
		return SCE_H_TAGUNKNOWN;
	case eScriptSGML:
		return SCE_H_SGML_DEFAULT;
	case eScriptComment:
		return SCE_H_COMMENT;
	default :
		return SCE_HJ_START;
	}
}

constexpr int defaultStateForSGML(script_type scriptLanguage) noexcept {
	return (scriptLanguage == eScriptSGMLblock)? SCE_H_SGML_BLOCK_DEFAULT : SCE_H_SGML_DEFAULT;
}

constexpr bool IsSGMLWordChar(int ch) noexcept {
	return ch >= 0x80 ||
		(IsAlphaNumeric(ch) || ch == '.' || ch == '_' || ch == ':' || ch == '!' || ch == '#');
}

constexpr bool InTagState(int state) noexcept {
	return AnyOf(state, SCE_H_TAG, SCE_H_TAGUNKNOWN, SCE_H_SCRIPT,
				SCE_H_ATTRIBUTE, SCE_H_ATTRIBUTEUNKNOWN,
				SCE_H_NUMBER, SCE_H_OTHER,
				SCE_H_DOUBLESTRING, SCE_H_SINGLESTRING);
}

constexpr bool IsHTMLWordChar(int ch) noexcept {
	return IsAlphaNumeric(ch) || AnyOf(ch, '.', '-', '_', ':', '!', '#') || ch >= 0x80;
}

constexpr bool IsTagContinue(int ch) noexcept {
	return IsAlphaNumeric(ch) || AnyOf(ch, '.', '-', '_', ':', '!', '#', '[', ']') || ch >= 0x80;
}

constexpr bool IsAttributeContinue(int ch) noexcept {
	return IsAlphaNumeric(ch) || AnyOf(ch, '.', '-', '_', ':', '!', '#', '/') || ch >= 0x80;
}

constexpr bool IsOKBeforeJSRE(int ch) noexcept {
	// TODO: also handle + and - (except if they're part of ++ or --) and return keywords
	return AnyOf(ch, '(', '[', '{', '=', ',', ':', ';', '!', '%', '^', '&', '*', '|', '?', '~', '>', ' ');
}

void ColouriseHyperTextDoc(Sci_PositionU startPos, Sci_Position length, int initStyle, LexerWordList keywordLists, Accessor &styler, bool isXml) {
	int StateToPrint = initStyle;
	int state = stateForPrintState(StateToPrint);

	// If inside a tag, it may be a script tag, so reread from the start of line starting tag to ensure any language tags are seen
	if (InTagState(state)) {
		while (startPos != 0) {
			state = styler.StyleIndexAt(startPos - 1);
			if (!InTagState(state)) {
				break;
			}
			const Sci_Position backLineStart = styler.LineStart(styler.GetLine(startPos - 1));
			length += startPos - backLineStart;
			startPos = backLineStart;
		}
		state = (startPos == 0) ? SCE_H_DEFAULT : state;
	}
	styler.StartAt(startPos);

	/* Nothing handles getting out of these, so we need not start in any of them.
	 * As we're at line start and they can't span lines, we'll re-detect them anyway */
	switch (state) {
		case SCE_H_QUESTION:
		case SCE_H_XMLSTART:
		case SCE_H_XMLEND:
		case SCE_H_ASP:
			state = SCE_H_DEFAULT;
			break;
	}

	Sci_Line lineCurrent = styler.GetLine(startPos);
	int lineState;
	if (lineCurrent > 0) {
		lineState = styler.GetLineState(lineCurrent-1);
	} else {
		// Default client and ASP scripting language is JavaScript
		lineState = eScriptJS << 8;

		// property asp.default.language
		//	Script in ASP code is initially assumed to be in JavaScript.
		//	To change this to VBScript set asp.default.language to 2.
		lineState |= styler.GetPropertyInt("asp.default.language", eScriptJS) << 4;
	}
	script_mode inScriptType = static_cast<script_mode>((lineState >> 0) & 0x03); // 2 bits of scripting mode
	bool tagOpened = (lineState >> 2) & 0x01; // 1 bit to know if we are in an opened tag
	bool tagClosing = (lineState >> 3) & 0x01; // 1 bit to know if we are in a closing tag
	bool tagDontFold = false; //some HTML tags should not be folded
	script_type aspScript = static_cast<script_type>((lineState >> 4) & 0x0F); // 4 bits of script name
	script_type clientScript = static_cast<script_type>((lineState >> 8) & 0x0F); // 4 bits of script name
	int beforePreProc = (lineState >> 12) & 0xFF; // 8 bits of state
	bool isLanguageType = (lineState >> 20) & 1; // type or language attribute for script tag
	int sgmlBlockLevel = (lineState >> 21);

	script_type scriptLanguage = ScriptOfState(state);
	// If eNonHtmlScript coincides with SCE_H_COMMENT, assume eScriptComment
	if (inScriptType == eNonHtmlScript && state == SCE_H_COMMENT) {
		scriptLanguage = eScriptComment;
	}
	script_type beforeLanguage = ScriptOfState(beforePreProc);

	// property fold.html
	//	Folding is turned on or off for HTML and XML files with this option.
	//	The fold option must also be on for folding to occur.
	constexpr bool foldHTML = true;//styler.GetPropertyBool("fold.html", true);

	const bool fold = foldHTML & styler.GetPropertyInt("fold");

	// property fold.html.preprocessor
	//	Folding is turned on or off for scripts embedded in HTML files with this option.
	//	The default is on.
	constexpr bool foldHTMLPreprocessor = foldHTML;// && styler.GetPropertyBool("fold.html.preprocessor", true);

	// property fold.xml.at.tag.open
	//	Enable folding for XML at the start of open tag.
	//	The default is on.
	const bool foldXmlAtTagOpen = isXml & fold;// && styler.GetPropertyBool("fold.xml.at.tag.open", true);

	// property lexer.xml.allow.scripts
	//	Set to 0 to disable scripts in XML.
	const bool allowScripts = styler.GetPropertyBool("lexer.xml.allow.scripts", true);

	int levelPrev = styler.LevelAt(lineCurrent) & SC_FOLDLEVELNUMBERMASK;
	int levelCurrent = levelPrev;

	int chPrev = ' ';
	int ch = ' ';
	int chPrevNonWhite = ' ';
	// look back to set chPrevNonWhite properly for better regex colouring
	if (scriptLanguage == eScriptJS && startPos > 0) {
		Sci_Position back = startPos;
		int style = 0;
		while (--back) {
			style = styler.StyleIndexAt(back);
			if (style < SCE_HJ_DEFAULT || style > SCE_HJ_COMMENTDOC)
				// includes SCE_HJ_COMMENT & SCE_HJ_COMMENTLINE
				break;
		}
		if (style == SCE_HJ_SYMBOLS) {
			chPrevNonWhite = styler.SafeGetUCharAt(back);
		}
	}

	styler.StartSegment(startPos);
	const Sci_Position lengthDoc = startPos + length;
	for (Sci_Position i = startPos; i < lengthDoc; i++) {
		const int chPrev2 = chPrev;
		chPrev = ch;
		if (!IsASpace(ch) && state != SCE_HJ_COMMENT &&
			state != SCE_HJ_COMMENTLINE && state != SCE_HJ_COMMENTDOC)
			chPrevNonWhite = ch;
		ch = static_cast<unsigned char>(styler[i]);
		int chNext = styler.SafeGetUCharAt(i + 1);
		const int chNext2 = styler.SafeGetUCharAt(i + 2);

		// Handle DBCS codepages
		if (styler.IsLeadByte(static_cast<unsigned char>(ch))) {
			chPrev = ' ';
			i += 1;
			continue;
		}

		// decide what is the current state to print (depending on the script tag)
		StateToPrint = statePrintForState(state, inScriptType);

		// handle script folding
		if (fold) {
			if (scriptLanguage == eScriptJS) {
				if (!AnyOf(state, SCE_HJ_COMMENTLINE, SCE_HJ_COMMENT, SCE_HJ_COMMENTDOC, SCE_HJ_DOUBLESTRING, SCE_HJ_SINGLESTRING, SCE_HJ_REGEX, SCE_HJ_TEMPLATELITERAL)) {
					if (ch == '{' || ch == '[' || ch == '(') {
						levelCurrent++;
					} else if (ch == '}' || ch == ']' || ch == ')') {
						levelCurrent--;
					}
				}
			}
		}

		if ((ch == '\r' && chNext != '\n') || (ch == '\n')) {
			// Trigger on CR only (Mac style) or either on LF from CR+LF (Dos/Win) or on LF alone (Unix)
			// Avoid triggering two times on Dos/Win
			// New line -> record any line state onto /next/ line
			if (fold) {
				levelCurrent = sci::max(levelCurrent, SC_FOLDLEVELBASE);
				int lev = levelPrev;
				if ((levelCurrent > levelPrev))
					lev |= SC_FOLDLEVELHEADERFLAG;

				styler.SetLevel(lineCurrent, lev);
				levelPrev = levelCurrent;
			}
			styler.SetLineState(lineCurrent,
			                    (static_cast<int>(inScriptType) << 0) |
			                    (static_cast<int>(tagOpened) << 2) |
			                    (static_cast<int>(tagClosing) << 3) |
			                    (static_cast<int>(aspScript) << 4) |
			                    (static_cast<int>(clientScript) << 8) |
			                    (beforePreProc << 12) |
			                    (static_cast<int>(isLanguageType) << 20) |
			                    (sgmlBlockLevel << 21));
			lineCurrent++;
		}

		// generic end of script processing
		else if ((inScriptType == eNonHtmlScript) && (ch == '<') && (chNext == '/')) {
			// Check if it's the end of the script tag (or any other HTML tag)
			switch (state) {
				// in these cases, you can embed HTML tags (to confirm !!!!!!!!!!!!!!!!!!!!!!)
			case SCE_H_DOUBLESTRING:
			case SCE_H_SINGLESTRING:
			case SCE_HJ_COMMENT:
			case SCE_HJ_COMMENTDOC:
			//case SCE_HJ_COMMENTLINE: // removed as this is a common thing done to hide
			// the end of script marker from some JS interpreters.
			//case SCE_HB_COMMENTLINE:
			case SCE_HBA_COMMENTLINE:
			case SCE_HJ_DOUBLESTRING:
			case SCE_HJ_SINGLESTRING:
			case SCE_HJ_TEMPLATELITERAL:
			case SCE_HJ_REGEX:
			case SCE_HB_STRING:
			case SCE_HBA_STRING:
				break;
			default :
				// check if the closing tag is a script tag
				{
					const bool match = (state == SCE_HJ_COMMENTLINE || state == SCE_HB_COMMENTLINE || isXml) ? styler.MatchLowerCase(i + 2, "script")
						: ((state == SCE_H_COMMENT) ? styler.MatchLowerCase(i + 2, "comment") : true);
					if (!match) {
						break;
					}
				}
				// closing tag of the script (it's a closing HTML tag anyway)
				styler.ColorTo(i, StateToPrint);
				state = SCE_H_TAGUNKNOWN;
				inScriptType = eHtml;
				scriptLanguage = eScriptNone;
				clientScript = eScriptJS;
				isLanguageType = false;
				i += 2;
				tagClosing = true;
				if (foldXmlAtTagOpen) {
					levelCurrent--;
				}
				continue;
			}
		}

		/////////////////////////////////////
		// handle the start of PHP pre-processor = Non-HTML
		else if (AnyOf(state, SCE_H_DEFAULT, SCE_H_SGML_BLOCK_DEFAULT) &&
		         (ch == '<') &&
		         (chNext == '?')) {
 			beforeLanguage = scriptLanguage;
			scriptLanguage = eScriptXML;
			styler.ColorTo(i, StateToPrint);
			beforePreProc = state;
			i++;
			styler.ColorTo(i + 1, SCE_H_XMLSTART);
			state = StateForScript(scriptLanguage);
			if (inScriptType == eNonHtmlScript)
				inScriptType = eNonHtmlScriptPreProc;
			else
				inScriptType = eNonHtmlPreProc;
			// should be better
			ch = chNext;
			continue;
		}

		// handle the start of ASP pre-processor = Non-HTML
		else if (state != SCE_H_CDATA && !isCommentASPState(state) && (ch == '<') && (chNext == '%')) {
			styler.ColorTo(i, StateToPrint);
			beforePreProc = state;
			if (inScriptType == eNonHtmlScript)
				inScriptType = eNonHtmlScriptPreProc;
			else
				inScriptType = eNonHtmlPreProc;
			// fold whole script
			if (foldHTMLPreprocessor) {
				levelCurrent++;
			}
			if (chNext2 == '@') {
				i += 2; // place as if it was the second next char treated
				state = SCE_H_ASPAT;
				scriptLanguage = eScriptVBS;
			} else if ((chNext2 == '-') && (styler.SafeGetCharAt(i + 3) == '-')) {
				styler.ColorTo(i + 4, SCE_H_ASP);
				state = SCE_H_XCCOMMENT;
				scriptLanguage = eScriptVBS;
				continue;
			} else {
				if (chNext2 == '=') {
					i += 2; // place as if it was the second next char treated
				} else {
					i++; // place as if it was the next char treated
				}

				state = StateForScript(aspScript);
				scriptLanguage = aspScript;
			}
			styler.ColorTo(i + 1, SCE_H_ASP);
			// should be better
			ch = styler.SafeGetUCharAt(i);
			continue;
		}

		/////////////////////////////////////
		// handle the start of SGML language (DTD)
		else if (AnyOf(scriptLanguage, eScriptNone, eScriptXML, eScriptSGMLblock) &&
				 (chPrev == '<') &&
				 (ch == '!') &&
				 AnyOf(state, SCE_H_DEFAULT, SCE_H_SGML_BLOCK_DEFAULT)) {
			beforePreProc = state;
			styler.ColorTo(i - 1, StateToPrint);
			if ((chNext == '-') && (chNext2 == '-')) {
				state = SCE_H_COMMENT; // wait for a pending command
				styler.ColorTo(i + 3, SCE_H_COMMENT);
				i += 2; // follow styling after the --
				if (!isXml) {
					// handle empty comment: <!-->, <!--->
					// https://html.spec.whatwg.org/multipage/parsing.html#parse-error-abrupt-closing-of-empty-comment
					chNext = styler.SafeGetUCharAt(i + 1);
					if ((chNext == '>') || (chNext == '-' && styler.SafeGetUCharAt(i + 2) == '>')) {
						if (chNext == '-') {
							i += 1;
						}
						chPrev = '-';
						ch = '-';
					}
				}
			} else if (styler.Match(i + 1, "[CDATA[")) {
				state = SCE_H_CDATA;
			} else {
				styler.ColorTo(i + 1, SCE_H_SGML_DEFAULT); // <! is default
				beforeLanguage = scriptLanguage;
				scriptLanguage = eScriptSGML;
				state = (chNext == '[') ? SCE_H_SGML_DEFAULT : SCE_H_SGML_COMMAND; // wait for a pending command
			}
			// fold whole tag (-- when closing the tag)
			if constexpr (foldHTMLPreprocessor || state == SCE_H_COMMENT || state == SCE_H_CDATA)
				levelCurrent++;
			continue;
		}

		// handle the end of a pre-processor = Non-HTML
		else if ((((inScriptType == eNonHtmlPreProc) || (inScriptType == eNonHtmlScriptPreProc)) &&
				  ((scriptLanguage != eScriptNone) && (chNext == '>') && stateAllowsTermination(state, ch))) ||
		         ((scriptLanguage == eScriptSGML) && (ch == '>') && !AnyOf(state, SCE_H_SGML_COMMENT, SCE_H_SGML_DOUBLESTRING, SCE_H_SGML_SIMPLESTRING))) {
			if (state == SCE_H_ASPAT) {
				aspScript = segIsScriptingIndicator(styler, styler.GetStartSegment(), i, aspScript);
			}
			// Bounce out of any ASP mode
			switch (state) {
			case SCE_HJ_WORD:
				classifyWordHTJS(i, keywordLists, styler, inScriptType);
				break;
			case SCE_HB_WORD:
				classifyWordHTVB(i, keywordLists, styler, inScriptType);
				break;
			case SCE_H_XCCOMMENT:
				styler.ColorTo(i, state);
				break;
			default :
				styler.ColorTo(i, StateToPrint);
				break;
			}
			if (scriptLanguage != eScriptSGML) {
				i++;
			}
			if (ch == '%')
				styler.ColorTo(i + 1, SCE_H_ASP);
			else if (scriptLanguage == eScriptXML)
				styler.ColorTo(i + 1, SCE_H_XMLSTART); // SCE_H_XMLEND
			else if (scriptLanguage == eScriptSGML)
				styler.ColorTo(i + 1, SCE_H_SGML_DEFAULT);
			else
				styler.ColorTo(i + 1, SCE_H_QUESTION);
			state = beforePreProc;
			if (inScriptType == eNonHtmlScriptPreProc)
				inScriptType = eNonHtmlScript;
			else
				inScriptType = eHtml;
			// Unfold all scripting languages, except for XML tag
			if (foldHTMLPreprocessor && (scriptLanguage != eScriptXML)) {
				levelCurrent--;
			}
			scriptLanguage = beforeLanguage;
			continue;
		}
		/////////////////////////////////////

		switch (state) {
		case SCE_H_DEFAULT:
			if (ch == '<') {
				// in HTML, fold on tag open and unfold on tag close
				tagOpened = true;
				tagClosing = (chNext == '/');
				if (foldXmlAtTagOpen && !AnyOf(chNext, '/', '?', '!', '-', '%')) {
					levelCurrent++;
				}
				if (foldXmlAtTagOpen && chNext == '/') {
					levelCurrent--;
				}
				styler.ColorTo(i, StateToPrint);
				if (chNext != '!')
					state = SCE_H_TAGUNKNOWN;
			} else if (ch == '&' && (IsAlpha(chNext) || chNext == '#')) {
				styler.ColorTo(i, SCE_H_DEFAULT);
				state = SCE_H_ENTITY;
			}
			break;
		case SCE_H_SGML_DEFAULT:
		case SCE_H_SGML_BLOCK_DEFAULT:
			if (ch == '\"') {
				styler.ColorTo(i, StateToPrint);
				state = SCE_H_SGML_DOUBLESTRING;
			} else if (ch == '\'') {
				styler.ColorTo(i, StateToPrint);
				state = SCE_H_SGML_SIMPLESTRING;
			} else if ((ch == '-') && (chPrev == '-')) {
				if (static_cast<Sci_Position>(styler.GetStartSegment()) <= (i - 2)) {
					styler.ColorTo(i - 1, StateToPrint);
				}
				state = SCE_H_SGML_COMMENT;
			} else if (ch == '%' && IsAlpha(chNext)) {
				styler.ColorTo(i, StateToPrint);
				state = SCE_H_SGML_ENTITY;
			} else if (ch == '#') {
				styler.ColorTo(i, StateToPrint);
				state = SCE_H_SGML_SPECIAL;
			} else if (ch == '[') {
				++sgmlBlockLevel;
				scriptLanguage = eScriptSGMLblock;
				state = SCE_H_SGML_BLOCK_DEFAULT;
				styler.ColorTo(i, StateToPrint);
				styler.ColorTo(i + 1, SCE_H_SGML_DEFAULT);
			} else if (ch == ']') {
				if (sgmlBlockLevel > 0) {
					--sgmlBlockLevel;
					if (sgmlBlockLevel == 0) {
						beforePreProc = SCE_H_DEFAULT;
					}
					scriptLanguage = eScriptSGML;
					state = SCE_H_SGML_DEFAULT;
					styler.ColorTo(i, StateToPrint);
					styler.ColorTo(i + 1, SCE_H_SGML_DEFAULT);
				} else {
					state = SCE_H_SGML_DEFAULT;
					styler.ColorTo(i, StateToPrint);
					styler.ColorTo(i + 1, SCE_H_SGML_ERROR);
				}
			}
			break;
		case SCE_H_SGML_COMMAND:
			if (!IsSGMLWordChar(ch)) {
				char s[15 + 1];
				styler.GetRange(styler.GetStartSegment(), i, s, sizeof(s));
				if (keywordLists[KeywordIndex_SGML].InList(s)) {
					styler.ColorTo(i, StateToPrint);
					state = SCE_H_SGML_1ST_PARAM;
				} else {
					state = SCE_H_SGML_ERROR;
				}
			}
			break;
		case SCE_H_SGML_1ST_PARAM:
			// wait for the beginning of the word
			if ((ch == '-') && (chPrev == '-')) {
				styler.ColorTo(i - 1, SCE_H_SGML_DEFAULT);
				state = SCE_H_SGML_1ST_PARAM_COMMENT;
			} else if (IsSGMLWordChar(ch)) {
				styler.ColorTo(i, SCE_H_SGML_DEFAULT);
				// find the length of the word
				do {
					ch = styler.SafeGetUCharAt(++i);
				} while (IsHTMLWordChar(ch));
				styler.ColorTo(i, StateToPrint);
				i -= 1;
				state = SCE_H_SGML_DEFAULT;
				continue;
			} else if (ch == '\"' || ch == '\'') {
				styler.ColorTo(i, SCE_H_SGML_DEFAULT);
				state = (ch == '\"')? SCE_H_SGML_DOUBLESTRING : SCE_H_SGML_SIMPLESTRING;
			}
			break;
		case SCE_H_SGML_ERROR:
			if ((ch == '-') && (chPrev == '-')) {
				styler.ColorTo(i - 1, StateToPrint);
				state = SCE_H_SGML_COMMENT;
			} else if (ch == '\"' || ch == '\'') {
				styler.ColorTo(i, SCE_H_SGML_DEFAULT);
				state = (ch == '\"')? SCE_H_SGML_DOUBLESTRING : SCE_H_SGML_SIMPLESTRING;
			}
			break;
		case SCE_H_SGML_DOUBLESTRING:
		case SCE_H_SGML_SIMPLESTRING:
			if (ch == ((state == SCE_H_SGML_DOUBLESTRING) ? '\"' : '\'')) {
				styler.ColorTo(i + 1, StateToPrint);
				state = SCE_H_SGML_DEFAULT;
			}
			break;
		case SCE_H_SGML_COMMENT:
			if ((ch == '-') && (chPrev == '-')) {
				styler.ColorTo(i + 1, StateToPrint);
				state = SCE_H_SGML_DEFAULT;
			}
			break;
		case SCE_H_CDATA:
			if ((chPrev2 == ']') && (chPrev == ']') && (ch == '>')) {
				styler.ColorTo(i + 1, StateToPrint);
				state = beforePreProc;
				levelCurrent--;
			}
			break;
		case SCE_H_COMMENT:
			if ((scriptLanguage != eScriptComment) && (chPrev2 == '-') && (chPrev == '-') && (ch == '>' || (!isXml && ch == '!' && chNext == '>'))) {
				// close HTML comment with --!>
				// https://html.spec.whatwg.org/multipage/parsing.html#parse-error-incorrectly-closed-comment
				if (ch == '!') {
					i += 1;
				}
				styler.ColorTo(i + 1, StateToPrint);
				state = beforePreProc;
				levelCurrent--;
			}
			break;
		case SCE_H_SGML_1ST_PARAM_COMMENT:
			if ((ch == '-') && (chPrev == '-')) {
				styler.ColorTo(i + 1, SCE_H_SGML_COMMENT);
				state = SCE_H_SGML_1ST_PARAM;
			}
			break;
		case SCE_H_SGML_SPECIAL:
			if (!IsUpperCase(ch)) {
				styler.ColorTo(i, StateToPrint);
				if (IsAlphaNumeric(ch)) {
					state = SCE_H_SGML_ERROR;
				} else {
					state = SCE_H_SGML_DEFAULT;
				}
			}
			break;
		case SCE_H_SGML_ENTITY:
			if (!IsSGMLEntityChar(ch)) {
				styler.ColorTo(i + 1, ((ch == ';') ? StateToPrint : SCE_H_SGML_ERROR));
				state = defaultStateForSGML(scriptLanguage);
			}
			break;
		case SCE_H_ENTITY:
			if (!IsEntityChar(ch)) {
				styler.ColorTo(i + (ch == ';'), ((ch == ';') ? StateToPrint : SCE_H_TAGUNKNOWN));
				state = SCE_H_DEFAULT;
				if (ch != ';' && IsAGraphic(ch)) {
					// Retreat one byte so the character that is invalid inside entity
					// may start something else like a tag.
					--i;
					continue;
				}
			}
			break;
		case SCE_H_TAGUNKNOWN:
			if (!IsTagContinue(ch) && !((ch == '/') && (chPrev == '<'))) {
				int eClass = classifyTagHTML(i, keywordLists, styler, tagDontFold, isXml, allowScripts);
				if (eClass == SCE_H_SCRIPT || eClass == SCE_H_COMMENT) {
					if (!tagClosing) {
						inScriptType = eNonHtmlScript;
						scriptLanguage = (eClass == SCE_H_SCRIPT) ? clientScript : eScriptComment;
					} else {
						scriptLanguage = eScriptNone;
					}
					isLanguageType = false;
					eClass = SCE_H_TAG;
				}
				if (ch == '>') {
					styler.ColorTo(i + 1, eClass);
					if (inScriptType == eNonHtmlScript) {
						state = StateForScript(scriptLanguage);
					} else {
						state = SCE_H_DEFAULT;
					}
					tagOpened = false;
					if (!(foldXmlAtTagOpen || tagDontFold)) {
						if (tagClosing) {
							levelCurrent--;
						} else {
							levelCurrent++;
						}
					}
					tagClosing = false;
				} else if (ch == '/' && chNext == '>') {
					if (eClass == SCE_H_TAGUNKNOWN) {
						styler.ColorTo(i + 2, SCE_H_TAGUNKNOWN);
					} else {
						styler.ColorTo(i, StateToPrint);
						styler.ColorTo(i + 2, SCE_H_TAG); // SCE_H_TAGEND
					}
					i++;
					ch = chNext;
					state = SCE_H_DEFAULT;
					tagOpened = false;
					if (foldXmlAtTagOpen) {
						levelCurrent--;
					}
				} else {
					if (eClass != SCE_H_TAGUNKNOWN) {
						if (eClass == SCE_H_SGML_DEFAULT) {
							state = SCE_H_SGML_DEFAULT;
						} else {
							state = SCE_H_OTHER;
						}
					} else {
						styler.ColorTo(i, eClass);
						state = SCE_H_OTHER;
					}
				}
			}
			break;
		case SCE_H_ATTRIBUTE:
			if (!IsAttributeContinue(ch)) {
				isLanguageType = classifyAttribHTML(i, keywordLists, styler, inScriptType, isXml);
				if (ch == '>') {
					styler.ColorTo(i + 1, SCE_H_TAG);
					if (inScriptType == eNonHtmlScript) {
						state = StateForScript(scriptLanguage);
					} else {
						state = SCE_H_DEFAULT;
					}
					tagOpened = false;
					if (!(foldXmlAtTagOpen || tagDontFold)) {
						if (tagClosing) {
							levelCurrent--;
						} else {
							levelCurrent++;
						}
					}
					tagClosing = false;
				} else if (ch == '=') {
					styler.ColorTo(i + 1, SCE_H_OTHER);
					state = SCE_H_VALUE;
				} else {
					state = SCE_H_OTHER;
				}
			}
			break;
		case SCE_H_OTHER:
			if (ch == '>') {
				styler.ColorTo(i, StateToPrint);
				styler.ColorTo(i + 1, SCE_H_TAG);
				if (inScriptType == eNonHtmlScript) {
					state = StateForScript(scriptLanguage);
				} else {
					state = SCE_H_DEFAULT;
				}
				tagOpened = false;
				if (!(foldXmlAtTagOpen || tagDontFold)) {
					if (tagClosing) {
						levelCurrent--;
					} else {
						levelCurrent++;
					}
				}
				tagClosing = false;
			} else if (ch == '\"') {
				styler.ColorTo(i, StateToPrint);
				state = SCE_H_DOUBLESTRING;
			} else if (ch == '\'') {
				styler.ColorTo(i, StateToPrint);
				state = SCE_H_SINGLESTRING;
			} else if (ch == '=') {
				styler.ColorTo(i + 1, StateToPrint);
				state = SCE_H_VALUE;
			} else if (ch == '/' && chNext == '>') {
				styler.ColorTo(i, StateToPrint);
				styler.ColorTo(i + 2, SCE_H_TAG); // SCE_H_TAGEND
				i++;
				ch = chNext;
				state = SCE_H_DEFAULT;
				tagOpened = false;
				if (foldXmlAtTagOpen) {
					levelCurrent--;
				}
			} else if (ch == '?' && chNext == '>') {
				styler.ColorTo(i, StateToPrint);
				styler.ColorTo(i + 2, SCE_H_XMLSTART); // SCE_H_XMLEND
				i++;
				ch = chNext;
				state = SCE_H_DEFAULT;
			} else if (IsHTMLWordChar(ch)) {
				styler.ColorTo(i, StateToPrint);
				state = SCE_H_ATTRIBUTE;
			}
			break;
		case SCE_H_DOUBLESTRING:
		case SCE_H_SINGLESTRING:
			if (ch == ((state == SCE_H_DOUBLESTRING) ? '\"' : '\'')) {
				if (isLanguageType) {
					scriptLanguage = segIsScriptingIndicator(styler, styler.GetStartSegment(), i, scriptLanguage);
					clientScript = scriptLanguage;
					isLanguageType = false;
				}
				styler.ColorTo(i + 1, state);
				state = SCE_H_OTHER;
			}
			break;
		case SCE_H_VALUE:
			if (IsHtmlInvalidAttrChar(ch)) {
				if (ch == '\"' && chPrev == '=') {
					// Should really test for being first character
					state = SCE_H_DOUBLESTRING;
				} else if (ch == '\'' && chPrev == '=') {
					state = SCE_H_SINGLESTRING;
				} else {
					if (IsNumberChar(styler[styler.GetStartSegment()])) {
						styler.ColorTo(i, SCE_H_NUMBER);
					} else {
						styler.ColorTo(i, StateToPrint);
					}
					if (ch == '>') {
						styler.ColorTo(i + 1, SCE_H_TAG);
						if (inScriptType == eNonHtmlScript) {
							state = StateForScript(scriptLanguage);
						} else {
							state = SCE_H_DEFAULT;
						}
						tagOpened = false;
						if (!tagDontFold) {
							if (tagClosing) {
								levelCurrent--;
							} else {
								levelCurrent++;
							}
						}
						tagClosing = false;
					} else {
						state = SCE_H_OTHER;
					}
				}
			}
			break;

		case SCE_HJ_DEFAULT:
		case SCE_HJ_START:
		case SCE_HJ_SYMBOLS:
			if (IsNumberStart(ch, chNext)) {
				styler.ColorTo(i, StateToPrint);
				state = SCE_HJ_NUMBER;
			} else if (IsJsIdentifierStart(ch)) {
				styler.ColorTo(i, StateToPrint);
				state = SCE_HJ_WORD;
			} else if (ch == '/' && chNext == '*') {
				styler.ColorTo(i, StateToPrint);
				i++;
				levelCurrent++;
				state = (chNext2 == '*') ? SCE_HJ_COMMENTDOC : SCE_HJ_COMMENT;
			} else if (ch == '/' && chNext == '/') {
				styler.ColorTo(i, StateToPrint);
				state = SCE_HJ_COMMENTLINE;
			} else if (ch == '/' && IsOKBeforeJSRE(chPrevNonWhite)) {
				styler.ColorTo(i, StateToPrint);
				state = SCE_HJ_REGEX;
			} else if (ch == '\"') {
				styler.ColorTo(i, StateToPrint);
				state = SCE_HJ_DOUBLESTRING;
			} else if (ch == '\'') {
				styler.ColorTo(i, StateToPrint);
				state = SCE_HJ_SINGLESTRING;
			} else if (ch == '`') {
				styler.ColorTo(i, StateToPrint);
				state = SCE_HJ_TEMPLATELITERAL;
			} else if ((ch == '<') && (chNext == '!') && (chNext2 == '-') &&
			           styler.SafeGetCharAt(i + 3) == '-') {
				styler.ColorTo(i, StateToPrint);
				state = SCE_HJ_COMMENTLINE;
			} else if ((ch == '-') && (chNext == '-') && (chNext2 == '>')) {
				styler.ColorTo(i, StateToPrint);
				state = SCE_HJ_COMMENTLINE;
				i += 2;
			} else if (isoperator(ch)) {
				styler.ColorTo(i, StateToPrint);
				styler.ColorTo(i + 1, statePrintForState(SCE_HJ_SYMBOLS, inScriptType));
				state = SCE_HJ_DEFAULT;
			} else if ((ch == ' ') || (ch == '\t')) {
				if (state == SCE_HJ_START) {
					styler.ColorTo(i, StateToPrint);
					state = SCE_HJ_DEFAULT;
				}
			}
			break;
		case SCE_HJ_WORD:
		case SCE_HJ_NUMBER:
			if (!(IsJsIdentifierChar(ch) || (state == SCE_HJ_NUMBER && IsNumberContinueEx(chPrev, ch, chNext)))) {
				if (state == SCE_HJ_NUMBER) {
					styler.ColorTo(i, statePrintForState(SCE_HJ_NUMBER, inScriptType));
				} else {
					classifyWordHTJS(i, keywordLists, styler, inScriptType);
				}
				state = SCE_HJ_DEFAULT;
			}
			break;
		case SCE_HJ_COMMENT:
		case SCE_HJ_COMMENTDOC:
			if (ch == '/' && chPrev == '*') {
				styler.ColorTo(i + 1, StateToPrint);
				state = SCE_HJ_DEFAULT;
				ch = ' ';
				levelCurrent--;
			}
			break;
		case SCE_HJ_COMMENTLINE:
			if (IsEOLChar(ch)) {
				styler.ColorTo(i, statePrintForState(SCE_HJ_COMMENTLINE, inScriptType));
				state = SCE_HJ_DEFAULT;
				ch = ' ';
			}
			break;
		case SCE_HJ_DOUBLESTRING:
		case SCE_HJ_SINGLESTRING:
		case SCE_HJ_TEMPLATELITERAL:
			if (ch == '\\') {
				if (IsAGraphic(chNext)) {
					i++;
				}
			} else if (ch == ((state == SCE_HJ_DOUBLESTRING) ? '\"' : ((state == SCE_HJ_SINGLESTRING) ? '\'' : '`'))) {
				styler.ColorTo(i + 1, statePrintForState(state, inScriptType));
				state = SCE_HJ_DEFAULT;
				continue;
			} else if (state != SCE_HJ_TEMPLATELITERAL && IsEOLChar(ch)) {
				styler.ColorTo(i, StateToPrint);
				if (chPrev != '\\' && (chPrev2 != '\\' || chPrev != '\r' || ch != '\n')) {
					state = SCE_HJ_STRINGEOL;
				}
			}
			break;
		case SCE_HJ_STRINGEOL:
			if (!IsEOLChar(ch)) {
				styler.ColorTo(i, StateToPrint);
				state = SCE_HJ_DEFAULT;
			} else if (!IsEOLChar(chNext)) {
				styler.ColorTo(i + 1, StateToPrint);
				state = SCE_HJ_DEFAULT;
			}
			break;
		case SCE_HJ_REGEX:
			if (ch == '\r' || ch == '\n' || ch == '/') {
				if (ch == '/') {
					while (IsLowerCase(chNext)) {   // gobble regex flags
						i++;
						ch = chNext;
						chNext = styler.SafeGetUCharAt(i + 1);
					}
				}
				styler.ColorTo(i + 1, StateToPrint);
				state = SCE_HJ_DEFAULT;
				continue;
			} else if (ch == '\\') {
				// Gobble up the quoted character
				if (IsAGraphic(chNext)) {
					i++;
					ch = chNext;
					chNext = chNext2;
				}
			}
			break;

		case SCE_HB_DEFAULT:
		case SCE_HB_START:
		case SCE_HB_OPERATOR:
			if (IsNumberStart(ch, chNext)) {
				styler.ColorTo(i, StateToPrint);
				state = SCE_HB_NUMBER;
			} else if (IsIdentifierStartEx(ch)) {
				styler.ColorTo(i, StateToPrint);
				state = SCE_HB_WORD;
			} else if (ch == '\'') {
				styler.ColorTo(i, StateToPrint);
				state = SCE_HB_COMMENTLINE;
			} else if (ch == '\"') {
				styler.ColorTo(i, StateToPrint);
				state = SCE_HB_STRING;
			} else if ((ch == '<') && (chNext == '!') && (chNext2 == '-') &&
			           styler.SafeGetCharAt(i + 3) == '-') {
				styler.ColorTo(i, StateToPrint);
				state = SCE_HB_COMMENTLINE;
			} else if (isoperator(ch)) {
				styler.ColorTo(i, StateToPrint);
				styler.ColorTo(i + 1, statePrintForState(SCE_HB_OPERATOR, inScriptType));
				state = SCE_HB_DEFAULT;
			} else if ((ch == ' ') || (ch == '\t')) {
				if (state == SCE_HB_START) {
					styler.ColorTo(i, StateToPrint);
					state = SCE_HB_DEFAULT;
				}
			}
			break;
		case SCE_HB_WORD:
		case SCE_HB_NUMBER:
			if (!(IsIdentifierCharEx(ch) || (state == SCE_HB_NUMBER && IsNumberContinue(chPrev, ch, chNext)))) {
				if (state == SCE_HB_NUMBER) {
					styler.ColorTo(i, statePrintForState(SCE_HB_NUMBER, inScriptType));
					state = SCE_HB_DEFAULT;
				} else {
					state = classifyWordHTVB(i, keywordLists, styler, inScriptType);
				}
			}
			break;
		case SCE_HB_STRING:
			if (ch == '\"') {
				styler.ColorTo(i + 1, StateToPrint);
				state = SCE_HB_DEFAULT;
				continue;
			} else if (IsEOLChar(ch)) {
				styler.ColorTo(i, StateToPrint);
				state = SCE_HB_STRINGEOL;
			}
			break;
		case SCE_HB_COMMENTLINE:
			if (IsEOLChar(ch)) {
				styler.ColorTo(i, StateToPrint);
				state = SCE_HB_DEFAULT;
			}
			break;
		case SCE_HB_STRINGEOL:
			if (!IsEOLChar(ch)) {
				styler.ColorTo(i, StateToPrint);
				state = SCE_HB_DEFAULT;
			} else if (!IsEOLChar(chNext)) {
				styler.ColorTo(i + 1, StateToPrint);
				state = SCE_HB_DEFAULT;
			}
			break;
		}

		// Some of the above terminated their lexeme but since the same character starts
		// the same class again, only reenter if non empty segment.

		if (state == SCE_HB_DEFAULT) {    // One of the above succeeded
			if (ch == '\"') {
				state = SCE_HB_STRING;
			} else if (ch == '\'') {
				state = SCE_HB_COMMENTLINE;
			} else if (IsIdentifierStart(ch)) {
				state = SCE_HB_WORD;
			} else if (isoperator(ch)) {
				styler.ColorTo(i + 1, statePrintForState(SCE_HB_OPERATOR, inScriptType));
			}
		} else if (state == SCE_HJ_DEFAULT) {    // One of the above succeeded
			if (ch == '/' && chNext == '*') {
				i++;
				levelCurrent++;
				state = (chNext2 == '*') ? SCE_HJ_COMMENTDOC : SCE_HJ_COMMENT;
			} else if (ch == '/' && chNext == '/') {
				state = SCE_HJ_COMMENTLINE;
			} else if (ch == '\"') {
				state = SCE_HJ_DOUBLESTRING;
			} else if (ch == '\'') {
				state = SCE_HJ_SINGLESTRING;
			} else if (ch == '`') {
				state = SCE_HJ_TEMPLATELITERAL;
			} else if (IsJsIdentifierStart(ch)) {
				state = SCE_HJ_WORD;
			} else if ((ch == '-') && (chNext == '-') && (chNext2 == '>')) {
				styler.ColorTo(i, StateToPrint);
				state = SCE_HJ_COMMENTLINE;
				i += 2;
			} else if (isoperator(ch)) {
				styler.ColorTo(i + 1, statePrintForState(SCE_HJ_SYMBOLS, inScriptType));
			}
		}
	}

	switch (state) {
	case SCE_HJ_WORD:
		classifyWordHTJS(lengthDoc, keywordLists, styler, inScriptType);
		break;
	case SCE_HB_WORD:
		classifyWordHTVB(lengthDoc, keywordLists, styler, inScriptType);
		break;
	default:
		if (static_cast<Sci_Position>(styler.GetStartSegment()) < lengthDoc) {
			StateToPrint = statePrintForState(state, inScriptType);
			styler.ColorTo(lengthDoc, StateToPrint);
		}
		break;
	}

	// Fill in the real level of the next line, keeping the current flags as they will be filled in later
	if (fold) {
		const int flagsNext = styler.LevelAt(lineCurrent) & ~SC_FOLDLEVELNUMBERMASK;
		styler.SetLevel(lineCurrent, levelPrev | flagsNext);
	}
}

void ColouriseXMLDoc(Sci_PositionU startPos, Sci_Position length, int initStyle, LexerWordList keywordLists, Accessor &styler) {
	// Passing in true because we're lexing XML
	ColouriseHyperTextDoc(startPos, length, initStyle, keywordLists, styler, true);
}

void ColouriseHTMLDoc(Sci_PositionU startPos, Sci_Position length, int initStyle, LexerWordList keywordLists, Accessor &styler) {
	// Passing in false because we're not lexing XML
	ColouriseHyperTextDoc(startPos, length, initStyle, keywordLists, styler, false);
}

}

extern const LexerModule lmHTML(SCLEX_HTML, ColouriseHTMLDoc, "hypertext");
extern const LexerModule lmXML(SCLEX_XML, ColouriseXMLDoc, "xml");
